<hr />

<h2 id="introduction">Introduction</h2>
<p><br /> Hey guys this is my write-up for a challenge called <code class="highlighter-rouge">collision</code> from <a href="http://pwnable.kr/">pwnable.kr</a>. It’s a very simple challenge, we need a password to make the program read the flag, the function that validates the given password is vulnerable to hash collision so we will exploit it.
<br /> Challenge Description :</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Daddy told me about cool MD5 hash collision today.
I wanna do something like that too!

ssh col@pwnable.kr -p2222 (pw:guest)
</code></pre></div></div>
<p><img src="/images/pwn/collision/0.png" alt="" /></p>
<hr />

<h2 id="code-analysis-tests">Code Analysis, Tests</h2>
<p><br /> <code class="highlighter-rouge">col.c</code> :</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
unsigned long hashcode = 0x21DD09EC;
unsigned long check_password(const char* p){
	int* ip = (int*)p;
	int i;
	int res=0;
	for(i=0; i&lt;5; i++){
		res += ip[i];
	}
	return res;
}

int main(int argc, char* argv[]){
	if(argc&lt;2){
		printf("usage : %s [passcode]\n", argv[0]);
		return 0;
	}
	if(strlen(argv[1]) != 20){
		printf("passcode length should be 20 bytes\n");
		return 0;
	}

	if(hashcode == check_password( argv[1] )){
		system("/bin/cat flag");
		return 0;
	}
	else
		printf("wrong passcode.\n");
	return 0;
}
</code></pre></div></div>
<p><br /> <code class="highlighter-rouge">main()</code> :</p>

<p><br /> Starting by the main function it checks if we have given the program an input and it checks if our input’s length is exactly 20 bytes. Then it checks if the return value of <code class="highlighter-rouge">check_password(our input)</code> is equal to <code class="highlighter-rouge">hashcode</code>, if we pass that check it will read the flag, otherwise it will print <code class="highlighter-rouge">wrong passcode.</code> and exit.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int main(int argc, char* argv[]){
	if(argc&lt;2){
		printf("usage : %s [passcode]\n", argv[0]);
		return 0;
	}
	if(strlen(argv[1]) != 20){
		printf("passcode length should be 20 bytes\n");
		return 0;
	}

	if(hashcode == check_password( argv[1] )){
		system("/bin/cat flag");
		return 0;
	}
	else
		printf("wrong passcode.\n");
	return 0;
}
</code></pre></div></div>
<p><br /> Looking up, we can see the declaration of the variable <code class="highlighter-rouge">hashcode</code>  :</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>unsigned long hashcode = 0x21DD09EC;
</code></pre></div></div>
<p><br /> That’s a hex value, let’s convert it to decimal with python :</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; 0x21DD09EC
568134124
</code></pre></div></div>
<p><br /> So we need our input to be 20 bytes length and we also need to make the function <code class="highlighter-rouge">check_password</code> return <code class="highlighter-rouge">568134124</code> when our input is given to it.
<br /> Let’s quickly try to simulate that in <code class="highlighter-rouge">gdb</code>.
<br /> I ran the program and set a breakpoint at main :</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gef➤  break main                                                                                                                                                                                         
Breakpoint 1 at 0x11b3                                                                                                                                                                                   
gef➤  r "AAAAAAAAAAAAAAAAAAAA"
Starting program: /root/Desktop/pwnable.kr/collision/col "AAAAAAAAAAAAAAAAAAAA"

Breakpoint 1, 0x00005555555551b3 in main ()
[ Legend: Modified register | Code | Heap | Stack | String ]
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── registers ────
$rax   : 0x00005555555551af  →  &lt;main+0&gt; push rbp
$rbx   : 0x0 
$rcx   : 0x00007ffff7fa9718  →  0x00007ffff7faad80  →  0x0000000000000000
$rdx   : 0x00007fffffffe160  →  0x00007fffffffe48b  →  "SHELL=/bin/bash"
$rsp   : 0x00007fffffffe060  →  0x0000555555555260  →  &lt;__libc_csu_init+0&gt; push r15
$rbp   : 0x00007fffffffe060  →  0x0000555555555260  →  &lt;__libc_csu_init+0&gt; push r15
$rsi   : 0x00007fffffffe148  →  0x00007fffffffe44f  →  "/root/Desktop/pwnable.kr/collision/col"
$rdi   : 0x2                                                                                                           
$rip   : 0x00005555555551b3  →  &lt;main+4&gt; sub rsp, 0x10
$r8    : 0x00007ffff7faad80  →  0x0000000000000000
$r9    : 0x00007ffff7faad80  →  0x0000000000000000
$r10   : 0x0
$r11   : 0x00007ffff7f6b1b0  →  0x0000800003400468
$r12   : 0x0000555555555080  →  &lt;_start+0&gt; xor ebp, ebp
$r13   : 0x00007fffffffe140  →  0x0000000000000002
$r14   : 0x0
$r15   : 0x0
$eflags: [ZERO carry PARITY adjust sign trap INTERRUPT direction overflow resume virtualx86 identification]
$cs: 0x0033 $ss: 0x002b $ds: 0x0000 $es: 0x0000 $fs: 0x0000 $gs: 0x0000
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── stack ────
0x00007fffffffe060│+0x0000: 0x0000555555555260  →  &lt;__libc_csu_init+0&gt; push r15  ← $rsp, $rbp
0x00007fffffffe068│+0x0008: 0x00007ffff7e1209b  →  &lt;__libc_start_main+235&gt; mov edi, eax
0x00007fffffffe070│+0x0010: 0x0000000000000000
0x00007fffffffe078│+0x0018: 0x00007fffffffe148  →  0x00007fffffffe44f  →  "/root/Desktop/pwnable.kr/collision/col"
0x00007fffffffe080│+0x0020: 0x0000000200040000
0x00007fffffffe088│+0x0028: 0x00005555555551af  →  &lt;main+0&gt; push rbp
0x00007fffffffe090│+0x0030: 0x0000000000000000
0x00007fffffffe098│+0x0038: 0xf6e7f80b45a87e3d
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── code:x86:64 ────
   0x5555555551ae &lt;check_password+73&gt; ret
   0x5555555551af &lt;main+0&gt;         push   rbp
   0x5555555551b0 &lt;main+1&gt;         mov    rbp, rsp
 → 0x5555555551b3 &lt;main+4&gt;         sub    rsp, 0x10
   0x5555555551b7 &lt;main+8&gt;         mov    DWORD PTR [rbp-0x4], edi
   0x5555555551ba &lt;main+11&gt;        mov    QWORD PTR [rbp-0x10], rsi
   0x5555555551be &lt;main+15&gt;        cmp    DWORD PTR [rbp-0x4], 0x1
   0x5555555551c2 &lt;main+19&gt;        jg     0x5555555551e6 &lt;main+55&gt;
   0x5555555551c4 &lt;main+21&gt;        mov    rax, QWORD PTR [rbp-0x10]
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── threads ────
[#0] Id 1, Name: "col", stopped, reason: BREAKPOINT
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── trace ────
[#0] 0x5555555551b3 → main()
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
gef➤
</code></pre></div></div>
<p><br /> Then I set a breakpoint before the return instruction in <code class="highlighter-rouge">check_password()</code> and continued the execution :</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gef➤  disas check_password
Dump of assembler code for function check_password:
   0x0000555555555165 &lt;+0&gt;:     push   rbp
   0x0000555555555166 &lt;+1&gt;:     mov    rbp,rsp
   0x0000555555555169 &lt;+4&gt;:     mov    QWORD PTR [rbp-0x18],rdi
   0x000055555555516d &lt;+8&gt;:     mov    rax,QWORD PTR [rbp-0x18]
   0x0000555555555171 &lt;+12&gt;:    mov    QWORD PTR [rbp-0x10],rax
   0x0000555555555175 &lt;+16&gt;:    mov    DWORD PTR [rbp-0x8],0x0
   0x000055555555517c &lt;+23&gt;:    mov    DWORD PTR [rbp-0x4],0x0
   0x0000555555555183 &lt;+30&gt;:    jmp    0x5555555551a2 &lt;check_password+61&gt;
   0x0000555555555185 &lt;+32&gt;:    mov    eax,DWORD PTR [rbp-0x4]
   0x0000555555555188 &lt;+35&gt;:    cdqe
   0x000055555555518a &lt;+37&gt;:    lea    rdx,[rax*4+0x0]
   0x0000555555555192 &lt;+45&gt;:    mov    rax,QWORD PTR [rbp-0x10]
   0x0000555555555196 &lt;+49&gt;:    add    rax,rdx
   0x0000555555555199 &lt;+52&gt;:    mov    eax,DWORD PTR [rax]
   0x000055555555519b &lt;+54&gt;:    add    DWORD PTR [rbp-0x8],eax
   0x000055555555519e &lt;+57&gt;:    add    DWORD PTR [rbp-0x4],0x1
   0x00005555555551a2 &lt;+61&gt;:    cmp    DWORD PTR [rbp-0x4],0x4
   0x00005555555551a6 &lt;+65&gt;:    jle    0x555555555185 &lt;check_password+32&gt;
   0x00005555555551a8 &lt;+67&gt;:    mov    eax,DWORD PTR [rbp-0x8]
   0x00005555555551ab &lt;+70&gt;:    cdqe
   0x00005555555551ad &lt;+72&gt;:    pop    rbp
   0x00005555555551ae &lt;+73&gt;:    ret
End of assembler dump.
gef➤  break *0x00005555555551ae
Breakpoint 2 at 0x5555555551ae
gef➤  c
Continuing.

Breakpoint 2, 0x00005555555551ae in check_password ()
[ Legend: Modified register | Code | Heap | Stack | String ]
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── registers ────
$rax   : 0x46464645
$rbx   : 0x0
$rcx   : 0x6
$rdx   : 0x10
$rsp   : 0x00007fffffffe048  →  0x0000555555555225  →  &lt;main+118&gt; mov rdx, rax
$rbp   : 0x00007fffffffe060  →  0x0000555555555260  →  &lt;__libc_csu_init+0&gt; push r15
$rsi   : 0x00007fffffffe148  →  0x00007fffffffe44f  →  "/root/Desktop/pwnable.kr/collision/col"
$rdi   : 0x00007fffffffe476  →  "AAAAAAAAAAAAAAAAAAAA"
$rip   : 0x00005555555551ae  →  &lt;check_password+73&gt; ret 
$r8    : 0x400
$r9    : 0x00007ffff7faad80  →  0x0000000000000000
$r10   : 0xfffffffffffff479
$r11   : 0x00007ffff7e861e0  →  &lt;__strlen_sse2+0&gt; pxor xmm0, xmm0
$r12   : 0x0000555555555080  →  &lt;_start+0&gt; xor ebp, ebp
$r13   : 0x00007fffffffe140  →  0x0000000000000002
$r14   : 0x0
$r15   : 0x0
$eflags: [zero carry parity adjust sign trap INTERRUPT direction overflow resume virtualx86 identification]
$cs: 0x0033 $ss: 0x002b $ds: 0x0000 $es: 0x0000 $fs: 0x0000 $gs: 0x0000
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── stack ────
0x00007fffffffe048│+0x0000: 0x0000555555555225  →  &lt;main+118&gt; mov rdx, rax       ← $rsp
0x00007fffffffe050│+0x0008: 0x00007fffffffe148  →  0x00007fffffffe44f  →  "/root/Desktop/pwnable.kr/collision/col"
0x00007fffffffe058│+0x0010: 0x0000000200000000
0x00007fffffffe060│+0x0018: 0x0000555555555260  →  &lt;__libc_csu_init+0&gt; push r15  ← $rbp
0x00007fffffffe068│+0x0020: 0x00007ffff7e1209b  →  &lt;__libc_start_main+235&gt; mov edi, eax
0x00007fffffffe070│+0x0028: 0x0000000000000000
0x00007fffffffe078│+0x0030: 0x00007fffffffe148  →  0x00007fffffffe44f  →  "/root/Desktop/pwnable.kr/collision/col"
0x00007fffffffe080│+0x0038: 0x0000000200040000
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── code:x86:64 ────
   0x5555555551a1 &lt;check_password+60&gt; add    DWORD PTR [rbx+0x7e04fc7d], eax
   0x5555555551a7 &lt;check_password+66&gt; fisttp QWORD PTR [rbx-0x67b707bb]
   0x5555555551ad &lt;check_password+72&gt; pop    rbp
 → 0x5555555551ae &lt;check_password+73&gt; ret    
   ↳  0x555555555225 &lt;main+118&gt;       mov    rdx, rax
      0x555555555228 &lt;main+121&gt;       mov    rax, QWORD PTR [rip+0x2e19]        # 0x555555558048 &lt;hashcode&gt;
      0x55555555522f &lt;main+128&gt;       cmp    rdx, rax
      0x555555555232 &lt;main+131&gt;       jne    0x55555555524c &lt;main+157&gt;
      0x555555555234 &lt;main+133&gt;       lea    rdi, [rip+0xe08]        # 0x555555556043
      0x55555555523b &lt;main+140&gt;       mov    eax, 0x0
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── threads ────
[#0] Id 1, Name: "col", stopped, reason: BREAKPOINT
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── trace ────
[#0] 0x5555555551ae → check_password()
[#1] 0x555555555225 → main()
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
gef➤
</code></pre></div></div>
<p><br /> The return value of <code class="highlighter-rouge">check_password()</code> is saved in <code class="highlighter-rouge">EAX</code> we need it to be <code class="highlighter-rouge">568134124</code> :</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gef➤  print $eax
$1 = 0x46464645
gef➤  set $eax=568134124
</code></pre></div></div>
<p><br /> Now if we continue execution it should attempt to execute <code class="highlighter-rouge">/bin/cat flag</code> :</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gef➤  c
Continuing.
[Detaching after fork from child process 3166]
/bin/cat: flag: No such file or directory
[Inferior 1 (process 3101) exited normally]
gef➤ 
</code></pre></div></div>
<p><br /> Great, now we need to find out how to make <code class="highlighter-rouge">check_password()</code> return that value, let’s look at the code.
<br /> <code class="highlighter-rouge">check_password()</code> :</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>unsigned long check_password(const char* p){
	int* ip = (int*)p;
	int i;
	int res=0;
	for(i=0; i&lt;5; i++){
		res += ip[i];
	}
	return res;
}
</code></pre></div></div>
<p><br /> This function casts the given passcode (<code class="highlighter-rouge">p</code>) into integer, declares <code class="highlighter-rouge">ip</code> which is an <a href="https://www.tutorialspoint.com/cprogramming/c_array_of_pointers.htm">array of pointers</a> starting with the pointer to <code class="highlighter-rouge">p</code>, and declares an <code class="highlighter-rouge">int</code> variable called <code class="highlighter-rouge">res</code> and gives it a value of <code class="highlighter-rouge">0</code> then it loops 5 times through <code class="highlighter-rouge">ip</code> (because length of <code class="highlighter-rouge">passcode</code> is 20, <code class="highlighter-rouge">20/4 == 5</code>) and adds each value to <code class="highlighter-rouge">res</code>, finally it returns <code class="highlighter-rouge">res</code>.
<br /> In case you’re confused, simply what happens is that it takes the given passcode which is 20 bytes length and divides it to 5 pieces (each piece 4 bytes) then it sums the decimal value of the 5 pieces and returns that value. For example the result of giving <code class="highlighter-rouge">check_password()</code> “AAAAAAAAAAAAAAAAAAAA” will be like this :</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"AAAA" + "AAAA" + "AAAA" + "AAAA" + "AAAA"
0x41414141 + 0x41414141 + 0x41414141 + 0x41414141 + 0x41414141
1094795585 + 1094795585 + 1094795585 + 1094795585 + 1094795585
res = 5473977925
</code></pre></div></div>
<p><br /> To verify that I took the main code and added some <code class="highlighter-rouge">printf</code> statements, test code looks like this :</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
unsigned long hashcode = 0x21DD09EC;
unsigned long check_password(const char* p){
	int* ip = (int*)p;
	int i;
	int res=0;
	for(i=0; i&lt;5; i++){
		res += ip[i];
		printf("\n--------------------------\n");
		printf("loop :  %i\n", i);
		printf("piece value : %i\n",ip[i] );
		printf("\n");
	}
	return res;
}

int main(int argc, char* argv[]){
	if(argc&lt;2){
		printf("usage : %s [passcode]\n", argv[0]);
		return 0;
	}
	if(strlen(argv[1]) != 20){
		printf("passcode length should be 20 bytes\n");
		return 0;
	}
	printf("hashcode : %i\n", hashcode);
	if(hashcode == check_password( argv[1] )){
		system("/bin/cat flag");
		return 0;
	}
	else
		printf("wrong passcode.\n");
	return 0;
}
</code></pre></div></div>
<p><br /> Let’s give it 20 A’s :</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@kali:~/Desktop/pwnable.kr/collision/test# ./test "AAAAAAAAAAAAAAAAAAAA"
hashcode : 568134124

--------------------------
loop :  0
piece value : 1094795585


--------------------------
loop :  1
piece value : 1094795585


--------------------------
loop :  2
piece value : 1094795585


--------------------------
loop :  3
piece value : 1094795585


--------------------------
loop :  4
piece value : 1094795585

wrong passcode.

</code></pre></div></div>
<p><br /> You can see that the 5 pieces are of the same value which is the value of <code class="highlighter-rouge">0x41414141</code> (4 A’s) :</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; 0x41414141
1094795585
</code></pre></div></div>
<p><br /> And if we give it <code class="highlighter-rouge">AAAABBBBCCCCDDDDEEEE</code> :</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@kali:~/Desktop/pwnable.kr/collision/test# ./test "AAAABBBBCCCCDDDDEEEE"         
hashcode : 568134124

--------------------------
loop :  0
piece value : 1094795585


--------------------------
loop :  1
piece value : 1111638594


--------------------------
loop :  2
piece value : 1128481603


--------------------------
loop :  3
piece value : 1145324612


--------------------------
loop :  4
piece value : 1162167621

wrong passcode.

</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; 0x41414141
1094795585
&gt;&gt;&gt; 0x42424242
1111638594
&gt;&gt;&gt; 0x43434343
1128481603
&gt;&gt;&gt; 0x44444444
1145324612
&gt;&gt;&gt; 0x45454545
1162167621
</code></pre></div></div>
<p><br /></p>
<hr />

<h2 id="exploitation">Exploitation</h2>
<p><br /> We need to come up with 5 pieces that add up to 568134124. 
<br /> We can divide the original value by 5 :</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; 568134124/5
113626824
</code></pre></div></div>
<p><br /> But 568134124 isn’t divisible by 5 :</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; 568134124%5
4
</code></pre></div></div>
<p><br /> We can use 113626824 as the first 4 pieces, to get the last piece we will multiply 113626824 by 4 and subtract the result from 568134124 :</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; 113626824 * 4
454507296
&gt;&gt;&gt; 568134124 - 454507296
113626828
</code></pre></div></div>
<p><br /> What’s left is to convert them to hex :</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; hex(113626824)
'0x6c5cec8'
&gt;&gt;&gt; hex(113626828)
'0x6c5cecc'
</code></pre></div></div>
<p><br /> And because it’s little endian we will reverse the order, final payload will be :</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python -c 'print "\xc8\xce\xc5\x06" * 4 + "\xcc\xce\xc5\x06"'
</code></pre></div></div>
<p><br /> Let’s test it :</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@kali:~/Desktop/pwnable.kr/collision/test# ./test `python -c 'print "\xc8\xce\xc5\x06" * 4 + "\xcc\xce\xc5\x06"'`                                                                 
ip : 1329747125

--------------------------
loop :  0
piece value : 113626824

--------------------------
loop :  1
piece value : 113626824

--------------------------
loop :  2
piece value : 113626824

--------------------------
loop :  3
piece value : 113626824

--------------------------
loop :  4
piece value : 113626828

/bin/cat: flag: No such file or directory
</code></pre></div></div>
<p><br /> It works.
<img src="/images/pwn/collision/1.png" alt="" />
<br /> And by the way what we did now is a <a href="https://learncryptography.com/hash-functions/hash-collision-attack">hash collision</a>, we made a hash function produce the same output for different inputs.
<br /> I also wrote small python script using <code class="highlighter-rouge">pwntools</code> :</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/usr/bin/python</span>
<span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">payload</span> <span class="o">=</span> <span class="n">p32</span><span class="p">(</span><span class="mh">0x6c5cec8</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="n">p32</span><span class="p">(</span><span class="mh">0x6c5cecc</span><span class="p">)</span>

<span class="n">r</span> <span class="o">=</span> <span class="n">ssh</span><span class="p">(</span><span class="s">'col'</span> <span class="p">,</span><span class="s">'pwnable.kr'</span> <span class="p">,</span><span class="n">password</span><span class="o">=</span><span class="s">'guest'</span><span class="p">,</span> <span class="n">port</span><span class="o">=</span><span class="mi">2222</span><span class="p">)</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="n">executable</span><span class="o">=</span><span class="s">'./col'</span><span class="p">,</span> <span class="n">argv</span><span class="o">=</span><span class="p">[</span><span class="s">'col'</span><span class="p">,</span><span class="n">payload</span><span class="p">])</span>
<span class="n">flag</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">recv</span><span class="p">()</span>
<span class="n">log</span><span class="o">.</span><span class="n">success</span><span class="p">(</span><span class="s">"Flag: "</span> <span class="o">+</span> <span class="n">flag</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="n">r</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</code></pre></div></div>
<p><img src="/images/pwn/collision/2.png" alt="" />
<br /> pwned !
<br /> That’s it , Feedback is appreciated !
<br /> Don’t forget to read the <a href="/categories">other write-ups</a> , Tweet about the write-up if you liked it , follow on twitter <a href="https://twitter.com/Ahm3d_H3sham">@Ahm3d_H3sham</a>
<br /> Thanks for reading.
<br /> Previous pwn write-up : <a href="/pwn/bof/">pwnable.kr - bof</a>
<br /></p>
<hr />

